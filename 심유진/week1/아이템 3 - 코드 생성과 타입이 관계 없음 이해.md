# 아이템 3 : 코드 생성과 타입이 관계 없음 이해하기

## 타입스크립트 컴파일러

- 최신 타입스크립트/자바스크립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일 → 타입영향 xx
- 코드의 타입 오류 체크

타입 오류가 있는 코드도 컴파일이 가능하다 → 컴파일과 타입체크가 분리 돼 있기 때문 

: 문제가 될 만한 부분을 알려 주지만, 그렇다고 빌드를 멈추지 않음

> **noEmitOnError** : 오류가 있을 때 컴파일하지 않기 설정
> 

### 그렇다면 … 코드 오류가 있을때?

- “컴파일에 문제가 있다” ❌
- “타입 체크에 문제가 있다” ⭕️

→ 때문에 문제가 된 오류를 수정하지 않더라도 (타입 변경없이) 애플리케이션의 다른 부분을 테스트 할 수 있다

```jsx
shape instanceof Rectangle 
```

- instanceof 체크 : 런타임에 실행
- Rectangle : 타입 → 타입체크는 따로

: 이 코드는 Rectangle **타입 체크**를 해야되기 때문에 **런타임 시점에 아무런 역할을 할 수 없다 😭**

---

## 타입이 런타임에 없기때문에… .

### 1. 타입 정보 유지 방법

- 속성 체크 : 런타임에 접근 가능
- shape의 타입을 Rectangle로 보정 → 오류 사라짐
- 태그 기법 : 런타임에 접근 가능한 타입 정보를 명시적으로 저장 ( 태그된 유니온과 속성 체크 방법 )
- 타입과 값을 툴다 사용하는 기법 : 타입을 클래스로 만들기

> 인터페이스 : 타입으로 사용 , 클래스 : 타입과 값으로 모두 사용 가능
> 

### 2. 타입 연산은 런타임에 영향을 주지 않습니다

 : 값을 정제하기 위해서는 런타임의 타입을 체크해야 하고 자바스크립트 연산을 통해 변환을 수행해야 한다. 

### 3. 런타임 타입은 선언된 타입과 다를 수 있습니다

: 타입 선언은 런타임에 제거가 된다 때문에 달라질 수 있다

### 4. 타입스크립트 타입으로는 함수를 오버로드 할 수 없습니다

## 왜 ❓

: 타입과 런타임의 동작이 무관하기 떄문에 → 매개변수의 타입은 런타임에서 일어나지 않아 함수 이름이 같고 매개변수가 달라도 그 차이를 구분하지 못해서 `중복된 함수로 취급`한다. 

→ 하나에 함수에 대해 여러 개의 선언문을 작성할 수 있지만 **구현체는 오직 하나**뿐이다. 

```jsx
function (a,b) {
	return a + b ;
}
const three = add(1,2); //타입이 number 
const twelve = add('1', '2'); //타입이 string 
```

### 타입스크립트 타입은 런타임 성능에 영향을 주지 않습니다

- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거가 되어 런타임 성능에 영향 x
- 타입스크립트의 정적 타입은 비용이 들지 않음
- 런타임 오버헤드 ❌
- 빌드타임 오버헤드 ⭕️ → 타입체크시의 오버헤드
- 호환성과 성능 사이의 선택은 컴파일 타깃과 언어 레벨이 결정한다